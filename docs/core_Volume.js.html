<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/Volume.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/Volume.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* 
 * Copyright 2017 albert.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* global LBGeometry, Leeboard, LBMath */

/**
 * 
 * @namespace LBVolume
 */
var LBVolume = LBVolume || {};

/**
 * Represents a tetrahedron.
 * @constructor
 * @param {Number[]} [vertices]    If defined an array containing the
 * four vertices for the tetrahedron. References to the vertices are used, they are not copied.
 * If not defined the vertices are all set to new instances of {@link LBGeometry.Vector3}.
 * @param {Number} [mass=Number.NaN] Optional mass associated with the tetra.
 * @returns {LBVolume.Tetra}
 */
LBVolume.Tetra = function(vertices, mass) {
    /**
     * The array of vertices of the tetra.
     * @type LBGeometry.Vector3
     */
    this.vertices = [];
    if (vertices) {
        for (var i = 0; i &lt; 4; ++i) {
            this.vertices.push(vertices[i]);
        }
    }
    else {
        for (var i = 0; i &lt; 4; ++i) {
            this.vertices.push(new LBGeometry.Vector3());
        }
    }
    
    /**
     * Mass associated with the volume, set to {@link Number.NaN} if a mass is not assigned.
     * @type Number
     */
    this.mass = Leeboard.isVar(mass) ? mass : Number.NaN;
};

LBVolume.Tetra._workingVertexArray = [ null, null, null, null, null, null, null, null ];
LBVolume.Tetra._workingVectorA = new LBGeometry.Vector3();
LBVolume.Tetra._workingVectorB = new LBGeometry.Vector3();
LBVolume.Tetra._workingVectorC = new LBGeometry.Vector3();
LBVolume.Tetra._workingArrayA = [];
LBVolume.Tetra._workingArrayB = [];
LBVolume.Tetra._workingArrayC = [];
LBVolume.Tetra._workingLine3 = new LBGeometry.Line3();
LBVolume.Tetra._workingOrderedIndices = [ 0, 1, 2, 3, 4, 5, 6, 7, 8];

LBVolume.Tetra.prototype = {
    /**
     * Creates a shallow copy of the tetra.
     * @returns {LBVolume.Tetra}    The shallow copy.
     */
    clone: function() {
        return new LBVolume.Tetra(this.vertices, this.mass);
    },
    
    /**
     * Takes all the vertices of the tetra and clones them, making them unique to this
     * tetra.
     * @returns {LBVolume.Tetra}    this.
     */
    makeVerticesUnique: function() {
        for (var i = 0; i &lt; this.vertices.length; ++i) {
            this.vertices[i] = this.vertices[i].clone();
        }
        return this;
    },
    
    /**
     * Computes the centroid (center of mass) of the tetra.
     * @param {LBGeometry.Vector3} [store] If defined the vector to store the centroid in.
     * @returns {LBGeometry.Vector3}    The centroid.
     */
    centroid: function(store) {
        store = store || new LBGeometry.Vector3();
        
        store.copy(this.vertices[0]);
        store.add(this.vertices[1]);
        store.add(this.vertices[2]);
        store.add(this.vertices[3]);
        store.divideScalar(4);
        
        return store;
    },
    
    /**
     * @returns {Number}    The volume of the tetrahedron.
     */
    volume: function() {
        // From https://en.wikipedia.org/wiki/Tetrahedron#Volume
        var a = LBVolume.Tetra._workingVectorA.copy(this.vertices[0]).sub(this.vertices[3]);
        var b = LBVolume.Tetra._workingVectorB.copy(this.vertices[1]).sub(this.vertices[3]);
        var c = LBVolume.Tetra._workingVectorC.copy(this.vertices[2]).sub(this.vertices[3]);
        b.cross(c);
        var volume = Math.abs(a.dot(b)) / 6;
        return volume;
    },
    
    /**
     * Creates a clone of this tetra that is mirrored about a plane.
     * @param {LBGeometry.Plane} plane  The mirror plane.
     * @returns {LBVolume.Tetra}
     */
    cloneMirrored: function(plane) {
        var clone = new LBVolume.Tetra(undefined, this.mass);
        for (var i = 0; i &lt; this.vertices.length; ++i) {
            LBGeometry.mirrorPointAboutPlane(plane, this.vertices[i], clone.vertices[i]);
        }
        return clone;
    },

    /**
     * Removes all references to other objects so this could hopefully be garbage collected.
     * @returns {undefined}
     */
    dispose: function() {
        this.vertices = null;
    },
    
    constructor: LBVolume.Tetra
};


/**
 * Calculates the center of mass and total mass of the tetras in an array of tetras.
 * @param {LBVolume.Tetra[]} tetras    The array of tetras.
 * @param {Object} [store]  If defined the object to store the results into.
 * @returns {Object}    The results, the position property is compatible with {@link LBGeometry.Vector3}
 * and contains the coordinates of the center of mass, the mass property is the total mass.
 */
LBVolume.Tetra.centerOfMassOfTetras = function(tetras, store) {
    store = store || {};
    
    var centroid = LBVolume.Tetra._workingVectorA;
    var sumX = 0, sumY = 0, sumZ = 0;
    var totalMass = 0;
    for (var i = 0; i &lt; tetras.length; ++i) {
        if (tetras[i].mass > 0) {
            var mass = tetras[i].mass;
            totalMass += mass;
            centroid = tetras[i].centroid(centroid);
            sumX += centroid.x * mass;
            sumY += centroid.y * mass;
            sumZ += centroid.z * mass;
        }
    }
    
    var x, y, z;
    if (totalMass > 0) {
        x = sumX / totalMass;
        y = sumY / totalMass;
        z = sumZ / totalMass;
    }
    else {
        x = y = z = 0;
    }
    
    if (!store.position) {
        store.position = new LBGeometry.Vector3(x, y, z);
    }
    else {
        store.position.set(x, y, z);
    }
    
    store.mass = totalMass;
    
    return store;
};


/**
 * Returns the total volume of tetras in an array.
 * @param {LBVolume.Tetra[]} tetras    The array of tetras.
 * @returns {Number}    The total volume.
 */
LBVolume.Tetra.totalVolumeOfTetras = function(tetras) {
    var vol = 0;
    for (var i = 0; i &lt; tetras.length; ++i) {
        vol += tetras[i].volume();
    }
    return vol;
};

/**
 * Allocates a mass amongst all the tetras in an array based upon the volume
 * of the tetras.
 * @param {LBVolume.Tetra[]} tetras    The array of tetras.
 * @param {Number} totalMass    The total mass to assign, may be {@link Number.NaN}.
 * @param {Number} [startIndex=0] If specified the index in tetras at which to start.
 * @param {Number} [endIndex=tetras.length] If specified the index after the last index
 * in tetras to process.
 * @returns {undefined}
 */
LBVolume.Tetra.allocateMassToTetras = function(tetras, totalMass, startIndex, endIndex) {
    startIndex = startIndex || 0;
    if (!Leeboard.isVar(endIndex)) {
        endIndex = tetras.length;
    }
    
    if (Number.isNaN(totalMass)) {
        for (var i = startIndex; i &lt; endIndex; ++i) {
            tetras[i].mass = Number.NaN;
        }
    }
    else {
        var volumes = [];
        var totalVol = 0;
        for (var i = startIndex; i &lt; endIndex; ++i) {
            var vol = tetras[i].volume();
            volumes.push(vol);
            totalVol += vol;
        }
        
        var massVol = (LBMath.isLikeZero(totalVol)) ? 0 : totalMass / totalVol;
        for (var i = startIndex; i &lt; endIndex; ++i) {
            tetras[i].mass = volumes[i] * massVol;
        }
    }
};

/**
 * Calculates a simplified inertia tensor from the tetras in a array of tetras. The
 * tensor is simplified in that each tetra is treated as a point mass at the centroid
 * of the tetra.
 * @param {LBVolume.Tetra[]} tetras    The array of tetras.
 * @param {LBGeometry.Matrix3} [tensor] If defined the 3x3 matrix to receive the tensor.
 * @returns {LBGeometry.Matrix3}    The tensor.
 */
LBVolume.Tetra.calcInertiaTensor = function(tetras, tensor) {
    tensor = tensor || new LBGeometry.Matrix3();
    tensor.zero();
    
    var centroid;
    
    for (var i = 0; i &lt; tetras.length; ++i) {
        var tetra = tetras[i];
        centroid = tetra.centroid(centroid);
        var xx = centroid.x * centroid.x;
        var yy = centroid.y * centroid.y;
        var zz = centroid.z * centroid.z;
        tensor.elements[0] += tetra.mass * (yy + zz);
        tensor.elements[4] += tetra.mass * (xx + zz);
        tensor.elements[8] += tetra.mass * (xx + yy);
        
        tensor.elements[1] += -tetra.mass * centroid.x * centroid.y;
        tensor.elements[2] += -tetra.mass * centroid.x * centroid.z;
        tensor.elements[5] += -tetra.mass * centroid.y * centroid.z;
    }
    
    tensor.elements[3] = tensor.elements[1];
    tensor.elements[6] = tensor.elements[2];
    tensor.elements[7] = tensor.elements[5];
    
    return tensor;
};

/**
 * Converts a set of 5 vertices describing a triangular bipyramid into an array of two tetrahedra
 * representing the volume.
 * &lt;p>
 * This is currently a fairly simple algorithm, it does not check for vertices lying on each
 * other, and expects the vertices in a particular order.
 * &lt;p>
 * The bipyramid must be described such that the first four vertices describe one tetrahedron,
 * and the last four vertices describe the other tetrahedron (the face v[1], v[2], v[3] is
 * internal and does not exist).
 * @param {Number[]} vertexIndices The array of indices of the vertices in vertexArray.
 * @param {LBGeometry.Vector3[]} vertexArray   The array of vertices.
 * @param {LBVolume.Tetra[]} [tetras]  If defined the array to store the tetras into. This array is NOT cleared.
 * @returns {LBVolume.Tetra[]} The array of the tetrahedra.
 */
LBVolume.Tetra.triangularBipyramidToTetras = function(vertexIndices, vertexArray, tetras) {
    if (!tetras) {
        tetras = [];
    }

    var vertices = LBVolume.Tetra._workingVertexArray;
    vertices[0] = vertexArray[vertexIndices[0]];
    vertices[1] = vertexArray[vertexIndices[1]];
    vertices[2] = vertexArray[vertexIndices[2]];
    vertices[3] = vertexArray[vertexIndices[3]];
    tetras.push(new LBVolume.Tetra(vertices));

    vertices[0] = vertexArray[vertexIndices[1]];
    vertices[1] = vertexArray[vertexIndices[2]];
    vertices[2] = vertexArray[vertexIndices[3]];
    vertices[3] = vertexArray[vertexIndices[4]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    return tetras;
};


/**
 * Converts a set of 6 vertices describing a triangular prism into an array of three tetrahedra
 * representing the volume.
 * &lt;p>
 * This is currently a fairly simple algorithm, it does not check for vertices lying on each
 * other, and expects the vertices in a particular order.
 * &lt;p>
 * The prism must be described such that the first 3 vertices represent one triangular
 * face and the second 3 vertices the other triangular face, and v[0] is connected to v[3],
 * v[1] is connected to v[4], and v[2] is connected to v[5].
 * @param {Number[]} vertexIndices The array of indices of the vertices in vertexArray.
 * @param {LBGeometry.Vector3[]} vertexArray   The array of vertices.
 * @param {LBVolume.Tetra[]} [tetras]  If defined the array to store the tetras into. This array is NOT cleared.
 * @returns {LBVolume.Tetra[]} The array of the tetrahedra.
 */
LBVolume.Tetra.triangularPrismToTetras = function(vertexIndices, vertexArray, tetras) {
    if (!tetras) {
        tetras = [];
    }

    var vertices = LBVolume.Tetra._workingVertexArray;
    vertices[0] = vertexArray[vertexIndices[0]];
    vertices[1] = vertexArray[vertexIndices[1]];
    vertices[2] = vertexArray[vertexIndices[2]];
    vertices[3] = vertexArray[vertexIndices[3]];
    tetras.push(new LBVolume.Tetra(vertices));

    vertices[0] = vertexArray[vertexIndices[3]];
    vertices[1] = vertexArray[vertexIndices[4]];
    vertices[2] = vertexArray[vertexIndices[5]];
    vertices[3] = vertexArray[vertexIndices[2]];
    tetras.push(new LBVolume.Tetra(vertices));

    vertices[0] = vertexArray[vertexIndices[3]];
    vertices[1] = vertexArray[vertexIndices[4]];
    vertices[2] = vertexArray[vertexIndices[1]];
    vertices[3] = vertexArray[vertexIndices[2]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    return tetras;
};


/**
 * Converts a set of 8 vertices describing a cuboid (a convex polyhedron with 6 quadrilateral faces)
 * into an array of 6 tetrahedra representing the volume.
 * &lt;p>
 * This is currently a fairly simple algorithm, it does not check for vertices lying on each
 * other, and expects the vertices in a particular order.
 * &lt;p>
 * The cuboid must be described such that the faces are described by the following index groups:
 * &lt;p>
 * &lt;li>0, 1, 2, 3
 * &lt;li>4, 5, 6, 7
 * &lt;li>4, 0, 3, 7
 * &lt;li>7, 3, 2, 7
 * &lt;li>6, 2, 1, 5
 * &lt;li>5, 1, 0, 4
 * &lt;p>
 * This is basically the first 4 vertices are one face and the second 4 vertices are the
 * opposite face, with the vertices on the each such that v[0] is connected to v[4], v[1]
 * is connected to v[5], etc.
 * @param {Number[]} vertexIndices The array of indices of the vertices in vertexArray.
 * @param {LBGeometry.Vector3[]} vertexArray   The array of vertices.
 * @param {LBVolume.Tetra[]} [tetras]  If defined the array to store the tetras into. This array is NOT cleared.
 * @returns {LBVolume.Tetra[]} The array of the tetrahedra.
 */
LBVolume.Tetra.cuboidToTetras = function(vertexIndices, vertexArray, tetras) {
    if (!tetras) {
        tetras = [];
    }

    var vertices = LBVolume.Tetra._workingVertexArray;

    vertices[0] = vertexArray[vertexIndices[0]];
    vertices[1] = vertexArray[vertexIndices[1]];
    vertices[2] = vertexArray[vertexIndices[2]];
    vertices[3] = vertexArray[vertexIndices[5]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    vertices[0] = vertexArray[vertexIndices[0]];
    vertices[1] = vertexArray[vertexIndices[2]];
    vertices[2] = vertexArray[vertexIndices[3]];
    vertices[3] = vertexArray[vertexIndices[5]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    vertices[0] = vertexArray[vertexIndices[2]];
    vertices[1] = vertexArray[vertexIndices[6]];
    vertices[2] = vertexArray[vertexIndices[3]];
    vertices[3] = vertexArray[vertexIndices[5]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    vertices[0] = vertexArray[vertexIndices[5]];
    vertices[1] = vertexArray[vertexIndices[6]];
    vertices[2] = vertexArray[vertexIndices[7]];
    vertices[3] = vertexArray[vertexIndices[3]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    vertices[0] = vertexArray[vertexIndices[5]];
    vertices[1] = vertexArray[vertexIndices[7]];
    vertices[2] = vertexArray[vertexIndices[4]];
    vertices[3] = vertexArray[vertexIndices[3]];
    tetras.push(new LBVolume.Tetra(vertices));
    
    vertices[0] = vertexArray[vertexIndices[5]];
    vertices[1] = vertexArray[vertexIndices[4]];
    vertices[2] = vertexArray[vertexIndices[3]];
    vertices[3] = vertexArray[vertexIndices[0]];
    tetras.push(new LBVolume.Tetra(vertices));

    return tetras;
};

/**
 * Determines where a plane slices a tetra, and if it does slice the tetra this
 * generates the tetras representing the volumes on each side of the plane.
 * @param {LBVolume.Tetra} tetra    The tetra of interest.
 * @param {LBGeometry.Plane} plane  The slicing plane.
 * @param {Boolean} [positiveDir=true]    If true then tetras are generated to represent
 * the volume on the side of the plane to which the normal points.
 * @param {Boolean} [negativeDir=true]    If true then tetras are generated to represent
 * the volume on the side of the plane to which the normal does not point.
 * @returns {undefined | LBVolume.Tetra[]}  If the plane does not slice the tetra,
 * returns undefined, otherwise an array of two elements, with the first element
 * an array containing the tetras for the volume on the positive side of the plane
 * (empty if positiveDir is false), and the second element an array containing the
 * tetras for the volume on the negative side of the plane (empty if negativeDir is false).
 */
LBVolume.Tetra.sliceWithPlane = function(tetra, plane, positiveDir, negativeDir) {
    
    // Sort the vertices to which side of the plane they lie.
    // We have the following cases:
    // All points on one side: No intersection.
    // One point on plane, other points on one side: No intersection.
    // One point on plane, one point on one side: A tetra on one side, two tetras on the other.
    // Two points on plane, one on each side: Two tetras, one on each side.
    // One point on one side: one tetra on one side, three on the other.
    // Two points on one side: three tetras on each side.
    var above = LBVolume.Tetra._workingArrayA;
    var below = LBVolume.Tetra._workingArrayB;
    var onPlane = LBVolume.Tetra._workingArrayC;
    above.splice(0, above.length);
    below.splice(0, below.length);
    onPlane.splice(0, onPlane.length);

    for (var i = 0; i &lt; 4; ++i) {
        var distance = plane.distanceToPoint(tetra.vertices[i]);
        if (LBMath.isLikeZero(distance)) {
            onPlane.push(i);
        }
        else if (distance > 0) {
            above.push(i);
        }
        else if (distance &lt; 0) {
            below.push(i);
        }
    }
    
    if (((onPlane.length + above.length) === 4) || ((onPlane.length + below.length) === 4)) {
        // No intersection...
        return undefined;
    }
    
    if (!Leeboard.isVar(positiveDir)) {
        positiveDir = true;
    }
    if (!Leeboard.isVar(negativeDir)) {
        negativeDir = true;
    }
    
    var aboveTetras = [];
    var belowTetras = [];
    
    var vertices = LBVolume.Tetra._workingVertexArray;
    var line = LBVolume.Tetra._workingLine3;
    var indices = LBVolume.Tetra._workingOrderedIndices;
    
    if (onPlane.length === 1) {
        // Divide into a tetra on one side, two tetras on the other.
        var singleTetras;
        var otherTetras;
        var singleIndices;
        var otherIndices;
        
        if (above.length === 1) {
            singleIndices = above;
            otherIndices = below;
            if (positiveDir) {
                singleTetras = aboveTetras;
            }
            if (negativeDir) {
                otherTetras = belowTetras;
            }
        }
        else {
            singleIndices = below;
            otherIndices = above;
            if (positiveDir) {
                otherTetras = aboveTetras;
            }
            if (negativeDir) {
                singleTetras = belowTetras;
            }
        }
        
        var singleVertex = tetra.vertices[singleIndices[0]];
        line.start.copy(singleVertex);
        
        var vertex0 = tetra.vertices[otherIndices[0]];
        line.end.copy(vertex0);
        var pointA = plane.intersectLine(line);
        
        var vertex1 = tetra.vertices[otherIndices[1]];
        line.end.copy(vertex1);
        var pointB = plane.intersectLine(line);
        
        if (singleTetras) {
            vertices[0] = tetra.vertices[onPlane[0]];
            vertices[1] = singleVertex;
            vertices[2] = pointA;
            vertices[3] = pointB;
            singleTetras.push(new LBVolume.Tetra(vertices));
        }
        if (otherTetras) {
            // Can't use vertices, since it's LBVolume.Tetra._workingVertexArray and
            // we can't pass it into an LBVolume.Tetra function...
            var myVertices = [vertex0, vertex1, tetra.vertices[onPlane[0]], pointA, pointB];
            LBVolume.Tetra.triangularBipyramidToTetras(indices, myVertices, otherTetras);
        }
    }
    else if (onPlane.length === 2) {
        // Divide into two tetras...
        vertices[0] = tetra.vertices[onPlane[0]];
        vertices[1] = tetra.vertices[onPlane[1]];
        
        line.start.copy(tetra.vertices[above[0]]);
        line.end.copy(tetra.vertices[below[0]]);
        vertices[2] = plane.intersectLine(line);
        
        if (positiveDir) {
            vertices[3] = tetra.vertices[above[0]];
            aboveTetras.push(new LBVolume.Tetra(vertices));
        }
        if (negativeDir) {
            vertices[3] = tetra.vertices[below[0]];
            belowTetras.push(new LBVolume.Tetra(vertices));
        }
    }
    else if ((above.length === 1) || (below.length === 1)) {
        // Single tetra on one side...
        var singleTetras;
        var otherTetras;
        var singleIndices;
        var otherIndices;

        if (above.length === 1) {
            singleIndices = above;
            otherIndices = below;
            if (positiveDir) {
                singleTetras = aboveTetras;
            }
            if (negativeDir) {
                otherTetras = belowTetras;
            }
        }
        else {
            singleIndices = below;
            otherIndices = above;
            if (positiveDir) {
                otherTetras = aboveTetras;
            }
            if (negativeDir) {
                singleTetras = belowTetras;
            }
        }
        
        var singleVertex = tetra.vertices[singleIndices[0]];
        line.start.copy(singleVertex);
        
        var vertex0 = tetra.vertices[otherIndices[0]];
        line.end.copy(vertex0);
        var pointA = plane.intersectLine(line);
        
        var vertex1 = tetra.vertices[otherIndices[1]];
        line.end.copy(vertex1);
        var pointB = plane.intersectLine(line);
        
        var vertex2 = tetra.vertices[otherIndices[2]];
        line.end.copy(vertex2);
        var pointC = plane.intersectLine(line);
        
        if (singleTetras) {
            vertices[0] = singleVertex;
            vertices[1] = pointA;
            vertices[2] = pointB;
            vertices[3] = pointC;
            singleTetras.push(new LBVolume.Tetra(vertices));
        }
        if (otherTetras) {
            // This is a triangular prism
            // Can't use vertices, since it's LBVolume.Tetra._workingVertexArray and
            // we can't pass it into an LBVolume.Tetra function...
            var myVertices = [vertex0, vertex1, vertex2, pointA, pointB, pointC ];
            LBVolume.Tetra.triangularPrismToTetras(indices, myVertices, otherTetras);
        }
    }
    else {
        // Two triangular prisms...
        var aboveA = tetra.vertices[above[0]];
        var aboveB = tetra.vertices[above[1]];
        var belowA = tetra.vertices[below[0]];
        var belowB = tetra.vertices[below[1]];
        
        line.start.copy(aboveA);
        line.end.copy(belowA);
        var ptAA = plane.intersectLine(line);
        
        line.end.copy(belowB);
        var ptAB = plane.intersectLine(line);
        
        line.start.copy(aboveB);
        var ptBB = plane.intersectLine(line);
        
        line.end.copy(belowA);
        var ptBA = plane.intersectLine(line);
        
        if (positiveDir) {
            var myVertices = [aboveA, ptAA, ptAB, aboveB, ptBA, ptBB];
            LBVolume.Tetra.triangularPrismToTetras(indices, myVertices, aboveTetras);
        }
        if (negativeDir) {
            var myVertices = [belowA, ptAA, ptAB, belowB, ptBA, ptBB];
            LBVolume.Tetra.triangularPrismToTetras(indices, myVertices, belowTetras);
        }
    }
    
    return [aboveTetras, belowTetras];
};


/**
 * Loads an array of tetras from properties in a data object.
 * @param {Object} data The data object.
 * @param {LBGeometry.Vector3[]} [vertices] If defined the array of vertices to use,
 * otherwise data should have a vertices property.
 * @param {LBVolume.Tetra[]} [tetras] If defined, the array to store the tetras into.
 * This is NOT cleared.
 * @returns {LBVolume.Tetra[]} The array of tetras.
 */
LBVolume.Tetra.loadFromData = function(data, vertices, tetras) {
    if (!vertices) {
        vertices = LBGeometry.loadVector3ArrayFromCoordArray(data.vertices);
    }
    if (!tetras) {
        tetras = [];
    }
    
    var firstIndex = tetras.length;
    
    for (var i = 0; i &lt; data.indices.length; ++i) {
        var item = data.indices[i];
        var indices;
        var mass;
        if (!Array.isArray(item)) {
            mass = Leeboard.isVar(item.mass) ? item.mass : Number.NaN;
            indices = item.indices;
        }
        else {
            mass = Number.NaN;
            indices = item;
        }
        
        var startIndex = tetras.length;
        switch (indices.length) {
            case 4 :
                var myVertices = LBVolume.Tetra._workingVertexArray;
                for (var j = 0; j &lt; 4; ++j) {
                    myVertices[j] = vertices[indices[j]];
                }
                tetras.push(new LBVolume.Tetra(myVertices));
                break;
                
            case 5 :
                LBVolume.Tetra.triangularBipyramidToTetras(indices, vertices, tetras);
                break;
                
            case 6 :
                LBVolume.Tetra.triangularPrismToTetras(indices, vertices, tetras);
                break;
                
            case 8 :
                LBVolume.Tetra.cuboidToTetras(indices, vertices, tetras);
                break;
                
            default :
                console.warn("LBVolume.Tetra.loadFromData: " + indices.length + " indices not supported, data.indices[" + i + "]");
                break;
        }
        
        if (!Number.isNaN(mass)) {
            LBVolume.Tetra.allocateMassToTetras(tetras, mass, startIndex, tetras.length);
        }
    }
    
    if (data.mirrorPlane) {
        var mirrorPlane = LBGeometry.loadPlane(data.mirrorPlane);
        if (!mirrorPlane) {
            console.warn("LBVolume.Tetra.loadFromData: data.mirrorPlane could not be loaded into an LBGeometry.Plane object.");
        }
        else {
            var endIndex = tetras.length;

            for (var i = firstIndex; i &lt; endIndex; ++i) {
                tetras.push(tetras[i].cloneMirrored(mirrorPlane));
            }
        }
    }
    
    return tetras;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="LBControls.CSplineValueMapper.html">CSplineValueMapper</a></li><li><a href="LBControls.SmoothController.html">SmoothController</a></li><li><a href="LBControls.SteppedController.html">SteppedController</a></li><li><a href="LBFoils.ClCd.html">ClCd</a></li><li><a href="LBFoils.ClCdCurve.html">ClCdCurve</a></li><li><a href="LBFoils.ClCdInterp.html">ClCdInterp</a></li><li><a href="LBFoils.ClCdStall.html">ClCdStall</a></li><li><a href="LBFoils.Foil.html">Foil</a></li><li><a href="LBGeometry.Euler.html">Euler</a></li><li><a href="LBGeometry.Line2.html">Line2</a></li><li><a href="LBGeometry.Line3.html">Line3</a></li><li><a href="LBGeometry.Plane.html">Plane</a></li><li><a href="LBGeometry.Sphere.html">Sphere</a></li><li><a href="LBGeometry.Vector2.html">Vector2</a></li><li><a href="LBGeometry.Vector3.html">Vector3</a></li><li><a href="LBMath.CSpline.html">CSpline</a></li><li><a href="LBPhaser.Arrow.html">Arrow</a></li><li><a href="LBPhaser.ArrowStyle.html">ArrowStyle</a></li><li><a href="LBPhaser.CannonLink.html">CannonLink</a></li><li><a href="LBPhaser.Dial.html">Dial</a></li><li><a href="LBPhaser.Env.html">Env</a></li><li><a href="LBPhaser.P2Link.html">P2Link</a></li><li><a href="LBPhaser.PhysicsLink.html">PhysicsLink</a></li><li><a href="LBPhaser.Slider.html">Slider</a></li><li><a href="LBPhysics.CoordSystemState.html">CoordSystemState</a></li><li><a href="LBPhysics.Resultant3D.html">Resultant3D</a></li><li><a href="LBPhysics.RigidBody.html">RigidBody</a></li><li><a href="LBSailSim.Env.html">Env</a></li><li><a href="LBSailSim.FoilInstance.html">FoilInstance</a></li><li><a href="LBSailSim.Hull.html">Hull</a></li><li><a href="LBSailSim.PhaserEnv.html">PhaserEnv</a></li><li><a href="LBSailSim.Propulsor.html">Propulsor</a></li><li><a href="LBSailSim.RudderController.html">RudderController</a></li><li><a href="LBSailSim.SailController.html">SailController</a></li><li><a href="LBSailSim.SailFoil.html">SailFoil</a></li><li><a href="LBSailSim.SailInstance.html">SailInstance</a></li><li><a href="LBSailSim.ThrottleController.html">ThrottleController</a></li><li><a href="LBSailSim.Vessel.html">Vessel</a></li><li><a href="LBSailSim.Water.html">Water</a></li><li><a href="LBSailSim.Wind.html">Wind</a></li><li><a href="LBVolume.Tetra.html">Tetra</a></li></ul><h3>Namespaces</h3><ul><li><a href="LBCannon.html">LBCannon</a></li><li><a href="LBControls.html">LBControls</a></li><li><a href="LBFoils.html">LBFoils</a></li><li><a href="LBGeometry.html">LBGeometry</a></li><li><a href="LBMath.html">LBMath</a></li><li><a href="LBPhaser.html">LBPhaser</a></li><li><a href="LBPhysics.html">LBPhysics</a></li><li><a href="LBSailSim.html">LBSailSim</a></li><li><a href="LBVolume.html">LBVolume</a></li><li><a href="Leeboard.html">Leeboard</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Jul 04 2017 20:54:03 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
